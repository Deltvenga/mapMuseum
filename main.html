<html>
<head>
	<meta charset="UTF-8">
</head>
<body>


	<style>
	    html, body, canvas, #canvas {
	        margin: 0;
	        padding: 0;
	    }

	    #systemLayer {
	    	position: absolute;
	    	left: 0px;
	    	top: 0px;
	    }

	</style>
	<canvas id="canvas"></canvas>
	<canvas id="systemLayer"></canvas>


	<script>

		var requestAnimFrame = window.requestAnimationFrame ||
						       window.webkitRequestAnimationFrame ||
						       window.mozRequestAnimationFrame ||
						       window.oRequestAnimationFrame ||
						       window.msRequestAnimationFrame;

		var ZOOM_SCALE = 0.2;
		var ZOOM_STEP = 5;
		var targetZoom = ZOOM_SCALE;

		var imageData;

		var ctx;

		var isGrabbing = false;
		var startGrabbingCoords = {x: -1, y: -1}

		var mouseCoords = {x: -1, y: -1};

		var system_image;

		function init() {
			var canvas = document.getElementById('canvas');
			canvas.height = window.innerHeight;
	        canvas.width = window.innerWidth;
			ctx = canvas.getContext('2d');

			var systemLayer = document.getElementById('systemLayer');
			systemLayer.height = window.innerHeight;
	        systemLayer.width = window.innerWidth;
			sysCtx = systemLayer.getContext('2d');

			base_image = new Image();
		    base_image.src = 'images/mainMap.png';
		    base_image.onload = function(){
		    	imageData = base_image;
		    	ctx.drawImage(base_image, 0, 0, base_image.width * ZOOM_SCALE, base_image.height * ZOOM_SCALE);

		    	system_image = new Image();
		    	system_image.src = 'images/pointMap.png';
		    	system_image.onload = function() {
		    		sysCtx.drawImage(system_image, 0, 0, system_image.width * ZOOM_SCALE, system_image.height * ZOOM_SCALE);
		    		loop();
		    	}

		    }
		}

		var translateCoords = {x: 0, y: 0, xPrev: 0, yPrev: 0};

		var prevZoomVal = 1;

		function loop() {
			document.getElementById('canvas').style.cursor = isGrabbing ? "grab" : "crosshair";
			ctx.clearRect(0, 0, 2000, 2000);
			sysCtx.clearRect(0, 0, 2000, 2000);
			ctx.translate(translateCoords.x + zoomDeltaCoords.x, translateCoords.y + zoomDeltaCoords.y);
			sysCtx.translate(translateCoords.x + zoomDeltaCoords.x, translateCoords.y + zoomDeltaCoords.y);
			prevZoomVal = ZOOM_SCALE;
			zoomHandler();

			ctx.drawImage(base_image, 0, 0, base_image.width * ZOOM_SCALE, base_image.height * ZOOM_SCALE);
			ctx.translate(-translateCoords.x-zoomDeltaCoords.x, -translateCoords.y-zoomDeltaCoords.y);
			sysCtx.drawImage(system_image, 0, 0, base_image.width * ZOOM_SCALE, base_image.height * ZOOM_SCALE);
			sysCtx.translate(-translateCoords.x-zoomDeltaCoords.x, -translateCoords.y-zoomDeltaCoords.y);
		    requestAnimFrame(loop);
		}

		function zoomHandler() {
			if(targetZoom != ZOOM_SCALE) {
				var zoomDirection = Number((Math.abs(targetZoom - ZOOM_SCALE)/20).toFixed(4));
				if(targetZoom < ZOOM_SCALE) {
					ZOOM_SCALE -= zoomDirection;
				} else {
					ZOOM_SCALE += zoomDirection;
				}
			}
		}

		document.addEventListener('mousemove', function (e) {
			mouseCoords.x = e.pageX;
			mouseCoords.y = e.pageY;
			if(isGrabbing) {
				translateCoords.x = translateCoords.xPrev+mouseCoords.x-startGrabbingCoords.x;
				translateCoords.y = translateCoords.yPrev+mouseCoords.y-startGrabbingCoords.y;
			}
		})

		var zoomDeltaCoords = {
			x: 0,
			y: 0
		}

		document.addEventListener('wheel', function(e) {
			
			var zoomStep = ZOOM_SCALE / ZOOM_STEP;

			var zoomDeltaStep = 20;

			if(e.deltaY > 0) {
				zoomStep = -zoomStep;
			}

			
			targetZoom = ZOOM_SCALE + zoomStep;
		});

		function rgbToHex(r, g, b) {
		    if (r > 255 || g > 255 || b > 255)
		        throw "Invalid color component";
		    return ((r << 16) | (g << 8) | b).toString(16);
		}

		function rgb2cmyk (r,g,b) {
			var computedC = 0;
			var computedM = 0;
			var computedY = 0;
			var computedK = 0;	
			//remove spaces from input RGB values, convert to int
			var r = parseInt( (''+r).replace(/\s/g,''),10 ); 
			var g = parseInt( (''+g).replace(/\s/g,''),10 ); 
			var b = parseInt( (''+b).replace(/\s/g,''),10 ); 	
			if ( r==null || g==null || b==null ||
			    isNaN(r) || isNaN(g)|| isNaN(b) )
			{
			  alert ('Please enter numeric RGB values!');
			  return;
			}
			if (r<0 || g<0 || b<0 || r>255 || g>255 || b>255) {
			  alert ('RGB values must be in the range 0 to 255.');
			  return;
			}	
			// BLACK
			if (r==0 && g==0 && b==0) {
			 computedK = 1;
			 return [0,0,0,1];
			}	
			computedC = 1 - (r/255);
			computedM = 1 - (g/255);
			computedY = 1 - (b/255);	
			var minCMY = Math.min(computedC,
			             Math.min(computedM,computedY));
			computedC = (computedC - minCMY) / (1 - minCMY) ;
			computedM = (computedM - minCMY) / (1 - minCMY) ;
			computedY = (computedY - minCMY) / (1 - minCMY) ;
			computedK = minCMY;	
			return [computedC,computedM,computedY,computedK];
		}

		document.addEventListener('mousedown', function(e) {
			isGrabbing = true;
			startGrabbingCoords.x = e.pageX;
			startGrabbingCoords.y = e.pageY;

			var x = e.pageX;
		    var y = e.pageY;
		    var p = sysCtx.getImageData(x, y, 1, 1).data; 
		    var hex = rgb2cmyk(p[0], p[1], p[2]);
		});
		
		document.addEventListener('mouseup', function(e) {
			isGrabbing = false;
			translateCoords.xPrev = translateCoords.x;
			translateCoords.yPrev = translateCoords.y;

		});	

		function pointInCircle(x, y, cx, cy, radius) {
			var distancesquared = (x - cx) * (x - cx) + (y - cy) * (y - cy);
			return distancesquared <= radius * radius;
		}

		init();
		




	</script>
</body>

</html>